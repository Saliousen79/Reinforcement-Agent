<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üö© Capture the Flag - 3D Visualisierung</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0f0f1a;
            color: #fff;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        /* ==================== */
        /* PANEL BASE STYLE     */
        /* ==================== */
        .panel {
            position: fixed;
            background: rgba(15, 15, 30, 0.92);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        /* ==================== */
        /* NAVIGATION           */
        /* ==================== */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid #2a2a3a;
            padding: 18px 0;
            z-index: 2000;
        }

        nav .nav-container {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        nav a {
            text-decoration: none;
            color: #b0b0c0;
            padding: 10px 22px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        nav a:hover {
            background: rgba(30, 30, 45, 0.85);
            color: #ffffff;
        }

        nav a.active {
            background: rgba(108, 99, 255, 0.15);
            color: #6c63ff;
            border-color: #6c63ff;
        }

        /* ==================== */
        /* SCOREBOARD           */
        /* ==================== */
        #scoreboard {
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            font-size: 1.5rem;
            font-weight: bold;
            z-index: 1500;
        }

        .blue-score { color: #4dabf7; }
        .red-score { color: #ff6b6b; }

        /* ==================== */
        /* FLAG STATUS          */
        /* ==================== */
        #flag-status {
            top: 140px;
            left: 50%;
            transform: translateX(-50%);
            min-width: 180px;
        }

        #flag-status h3 {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .flag-holder {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .flag-holder:last-child {
            border-bottom: none;
        }

        .flag-icon {
            font-size: 1.2rem;
        }

        .flag-holder .team-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .team-dot.blue { background: #4dabf7; }
        .team-dot.red { background: #ff6b6b; }

        .flag-holder .carrier-name {
            font-weight: 500;
            font-size: 0.95rem;
        }

        .flag-holder.carried .carrier-name {
            color: #ffd43b;
            animation: pulse-text 1.5s ease-in-out infinite;
        }

        .flag-holder.at-base .carrier-name {
            color: #666;
            font-style: italic;
        }

        @keyframes pulse-text {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* ==================== */
        /* REPLAY LISTE SIDEBAR */
        /* ==================== */
        #replay-sidebar {
            position: fixed;
            top: 80px;
            left: 20px;
            width: 320px;
            max-height: calc(100vh - 100px);
            background: rgba(15, 15, 30, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            z-index: 1500;
        }

        #replay-sidebar > h3 {
            font-size: 1.1rem;
            color: #6c63ff;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Modell-Gruppen */
        .model-group {
            margin-bottom: 16px;
        }

        .model-group-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 14px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border-left: 4px solid;
        }

        .model-group-header.charlie {
            border-left-color: #ffd43b;
            background: rgba(255, 212, 59, 0.05);
        }
        .model-group-header.gordon {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.05);
        }
        .model-group-header.algernon {
            border-left-color: #69db7c;
            background: rgba(105, 219, 124, 0.05);
        }

        .model-group-header .model-name {
            font-weight: 700;
            font-size: 1rem;
        }
        .model-group-header.charlie .model-name { color: #ffd43b; }
        .model-group-header.gordon .model-name { color: #ff6b6b; }
        .model-group-header.algernon .model-name { color: #69db7c; }

        .model-group-header .model-tag {
            margin-left: auto;
            font-size: 0.65rem;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        .model-group-header.charlie .model-tag {
            background: rgba(255, 212, 59, 0.2);
            color: #ffd43b;
        }
        .model-group-header.gordon .model-tag {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }
        .model-group-header.algernon .model-tag {
            background: rgba(105, 219, 124, 0.2);
            color: #69db7c;
        }

        /* Replay Items */
        .replay-list-item {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            padding: 10px 14px;
            margin-bottom: 6px;
            margin-left: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .replay-list-item:hover {
            transform: translateX(4px);
        }

        /* Modell-spezifische Hover & Active States */
        .replay-list-item.charlie:hover {
            background: rgba(255, 212, 59, 0.1);
            border-color: rgba(255, 212, 59, 0.3);
        }
        .replay-list-item.charlie.active {
            background: rgba(255, 212, 59, 0.15);
            border-color: #ffd43b;
        }

        .replay-list-item.gordon:hover {
            background: rgba(255, 107, 107, 0.1);
            border-color: rgba(255, 107, 107, 0.3);
        }
        .replay-list-item.gordon.active {
            background: rgba(255, 107, 107, 0.15);
            border-color: #ff6b6b;
        }

        .replay-list-item.algernon:hover {
            background: rgba(105, 219, 124, 0.1);
            border-color: rgba(105, 219, 124, 0.3);
        }
        .replay-list-item.algernon.active {
            background: rgba(105, 219, 124, 0.15);
            border-color: #69db7c;
        }

        .replay-list-item .replay-name {
            font-weight: 500;
            font-size: 0.9rem;
            color: #ccc;
        }

        .replay-list-item.active .replay-name {
            color: #fff;
        }

        .replay-list-item .step-badge {
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            color: #666;
        }

        .replay-list-item.active .step-badge {
            background: rgba(255, 255, 255, 0.1);
            color: #aaa;
        }

        /* Upload Section */
        .upload-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .upload-btn {
            width: 100%;
            background: rgba(108, 99, 255, 0.1);
            border: 1px solid rgba(108, 99, 255, 0.3);
            color: #a29bff;
            padding: 10px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .upload-btn:hover {
            background: rgba(108, 99, 255, 0.2);
            border-color: #6c63ff;
            color: #fff;
        }

        /* ==================== */
        /* REPLAY KONTEXT PANEL */
        /* ==================== */
        #replay-context {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 340px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            background: rgba(15, 15, 30, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 1500;
        }

        #replay-context h3 {
            font-size: 1rem;
            color: #6c63ff;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #replay-context h3::before {
            content: 'üìñ';
        }

        #replay-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
        }

        #replay-description {
            font-size: 0.9rem;
            color: #aaa;
            line-height: 1.6;
        }

        #replay-description p {
            margin-bottom: 10px;
        }

        #replay-description .highlight {
            color: #ffd43b;
            font-weight: 500;
        }

        #replay-description .blue-text {
            color: #4dabf7;
        }

        #replay-description .red-text {
            color: #ff6b6b;
        }

        #replay-meta {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.8rem;
            color: #666;
        }

        #replay-meta .meta-item {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
        }

        #replay-meta .meta-value {
            color: #888;
        }

        /* Kein Replay ausgew√§hlt */
        #no-replay-hint {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 20px 0;
        }

        /* Tags */
        .replay-tags {
            margin-top: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .replay-tag {
            display: inline-block;
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tag-training { background: #228be6; }
        .tag-demo { background: #fab005; color: #000; }
        .tag-interesting { background: #ae3ec9; }
        .tag-bug { background: #fa5252; }
        .tag-custom { background: #495057; }

        /* ==================== */
        /* CONTROLS             */
        /* ==================== */
        #controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
        }

        button {
            background: #2a2a4a;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }

        button:hover {
            background: #3a3a6a;
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-1px);
        }

        button.active {
            background: #6c63ff;
            border-color: #6c63ff;
        }

        #speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #aaa;
        }

        input[type="range"] {
            width: 80px;
            accent-color: #6c63ff;
        }

        select {
            background: #2a2a4a;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            max-width: 220px;
        }

        #step-info {
            bottom: 20px;
            left: 20px;
        }

        #step-display {
            font-size: 1.8rem;
            font-weight: bold;
            color: #6c63ff;
        }

        /* ==================== */
        /* LEGEND               */
        /* ==================== */
        #legend {
            top: 500px;
            left: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .blue { background: #4dabf7; }
        .red { background: #ff6b6b; }
        .flag { background: #ffd43b; }
        .stunned { background: #555555; }

        /* ==================== */
        /* LOADING              */
        /* ==================== */
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #6c63ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 12px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        input[type="file"] {
            display: none;
        }

        /* Keyboard hints */
        #keyboard-hints {
            position: fixed;
            bottom: 80px;
            left: 20px;
            font-size: 0.75rem;
            color: #555;
        }

        #keyboard-hints kbd {
            background: #2a2a4a;
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 4px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <nav>
        <div class="nav-container">
            <a href="../index.html">Home</a>
            <a href="../dokumentation.html">Dokumentation</a>
            <a href="../visualization/index.html" class="active">Visualisierung</a>
            <a href="../kennzahlen.html">Kennzahlen</a>
        </div>
    </nav>

    <div id="canvas-container"></div>

    <div id="loading">
        <div class="spinner"></div>
        <p>Lade Episode...</p>
    </div>

    <!-- REPLAY LISTE SIDEBAR -->
    <div id="replay-sidebar">
        <h3>üìÅ Replays</h3>
        
        <!-- Charlie Gruppe -->
        <div class="model-group">
            <div class="model-group-header charlie">
                <span class="model-name">Charlie</span>
                <span class="model-tag">Sparse</span>
            </div>
            <div class="model-replays" data-model="charlie">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
        </div>

        <!-- Gordon Gruppe -->
        <div class="model-group">
            <div class="model-group-header gordon">
                <span class="model-name">Gordon</span>
                <span class="model-tag">Dense</span>
            </div>
            <div class="model-replays" data-model="gordon">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
        </div>

        <!-- Algernon Gruppe -->
        <div class="model-group">
            <div class="model-group-header algernon">
                <span class="model-name">Algernon</span>
                <span class="model-tag">Balanced</span>
            </div>
            <div class="model-replays" data-model="algernon">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
        </div>

        <!-- Upload -->
        <div class="upload-section">
            <button class="upload-btn" id="file-upload-btn">üìÅ Eigenes Replay laden</button>
        </div>
    </div>

    <div class="panel" id="scoreboard">
        <span class="blue-score">Blue: <span id="blue-score">0</span></span>
        <span style="color: #666;">vs</span>
        <span class="red-score">Red: <span id="red-score">0</span></span>
    </div>

    <div class="panel" id="flag-status">
        <h3>üö© Flaggen</h3>
        <div class="flag-holder at-base" id="blue-flag-status">
            <span class="flag-icon">üîµ</span>
            <span class="team-dot blue"></span>
            <span class="carrier-name">An der Basis</span>
        </div>
        <div class="flag-holder at-base" id="red-flag-status">
            <span class="flag-icon">üî¥</span>
            <span class="team-dot red"></span>
            <span class="carrier-name">An der Basis</span>
        </div>
    </div>

    <!-- REPLAY KONTEXT PANEL -->
    <div class="panel" id="replay-context">
        <h3>Replay Kontext</h3>
        <div id="replay-title">Kein Replay geladen</div>
        <div id="replay-description">
            <p id="no-replay-hint">W√§hle ein Replay aus der Liste oder lade eine eigene Datei.</p>
        </div>
        <div id="replay-tags" class="replay-tags"></div>
        <div id="replay-meta" style="display: none;">
            <div class="meta-item">
                <span>Frames:</span>
                <span class="meta-value" id="meta-frames">-</span>
            </div>
            <div class="meta-item">
                <span>Agenten:</span>
                <span class="meta-value" id="meta-agents">-</span>
            </div>
            <div class="meta-item">
                <span>Map:</span>
                <span class="meta-value" id="meta-map">-</span>
            </div>
        </div>
    </div>

    <div class="panel" id="controls">
        <button id="play-btn" class="active">‚ñ∂ Play</button>
        <button id="pause-btn">‚è∏ Pause</button>
        <button id="reset-btn">‚Ü∫ Reset</button>
        <div id="speed-control">
            <span>Speed:</span>
            <input type="range" id="speed" min="0.5" max="3" step="0.5" value="1">
            <span id="speed-val">1x</span>
        </div>
        <input type="file" id="file-input" accept=".json">
    </div>

    <div class="panel" id="step-info">
        <div id="step-display">Step: 0</div>
    </div>

    <div class="panel" id="legend">
        <div class="legend-item"><div class="legend-color blue"></div> Blue Team</div>
        <div class="legend-item"><div class="legend-color red"></div> Red Team</div>
        <div class="legend-item"><div class="legend-color flag"></div> Flaggentr√§ger (Glow)</div>
        <div class="legend-item"><div class="legend-color stunned"></div> Bet√§ubt (‚≠ê Sterne)</div>
    </div>

    <div id="keyboard-hints">
        <kbd>Maus</kbd> Kamera drehen ¬∑ <kbd>Scroll</kbd> Zoom
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    
    <!-- ================================== -->
    <!-- EMBEDDED REPLAYS KONFIGURATION     -->
    <!-- ================================== -->
    <script>
        // REPLAY KONFIGURATION
        window.EMBEDDED_REPLAYS = [
            // =========================================
            // CHARLIE (Sparse Rewards)
            // =========================================
            {
                id: 'charlie_40m',
                filename: 'replays/Charlie_40M.json',
                title: 'Charlie - 40M Steps',
                shortDesc: 'Sparse Rewards - Fr√ºhe Phase',
                description: `
                    <p><span class="highlight">Charlie</span> nutzt <strong>Sparse Rewards</strong> - er bekommt nur f√ºr Captures und Sieg/Niederlage Feedback.</p>
                    <p>Bei <strong>40M Steps</strong> zeigt Charlie noch wenig taktisches Verst√§ndnis. Er experimentiert viel und entwickelt langsam erste Strategien.</p>
                    <p>‚ö†Ô∏è Viele zuf√§llige Bewegungen, wenig Koordination</p>
                `,
                tags: ['training', 'sparse'],
            },
            {
                id: 'charlie_80m',
                filename: 'replays/Charlie_80M.json',
                title: 'Charlie - 80M Steps',
                shortDesc: 'Sparse Rewards - Fortgeschritten',
                description: `
                    <p>Bei <strong>80M Steps</strong> hat Charlie deutliche Fortschritte gemacht. Er versteht das Spielziel besser.</p>
                    <p>‚úÖ Entwickelt erste Muster<br>
                    ‚ö†Ô∏è Immer noch ineffizient im Vergleich zu Dense-Agenten</p>
                `,
                tags: ['training', 'sparse'],
            },
            {
                id: 'charlie_100m',
                filename: 'replays/Charlie_100M.json',
                title: 'Charlie - 100M Steps',
                shortDesc: 'Sparse Rewards - Final',
                description: `
                    <p>Finales Modell nach <strong>100M Steps</strong>. Charlie zeigt kreative, aber unvorhersehbare Strategien.</p>
                    <p>‚úÖ Kreative L√∂sungen<br>
                    ‚ö†Ô∏è Langsames Lernen<br>
                    ‚úÖ Kein Reward Hacking</p>
                `,
                tags: ['training', 'sparse'],
            },

            // =========================================
            // GORDON (Dense Rewards)
            // =========================================
            {
                id: 'gordon_40m',
                filename: 'replays/Gordon_40M.json',
                title: 'Gordon - 40M Steps',
                shortDesc: 'Dense Rewards - Fr√ºhe Phase',
                description: `
                    <p><span class="highlight">Gordon</span> nutzt <strong>Dense Rewards</strong> - er bekommt f√ºr fast alles Feedback.</p>
                    <p>Schon bei <strong>40M Steps</strong> zeigt Gordon deutlich mehr Aktivit√§t als Charlie. Er lernt schnell, aber nicht immer die richtigen Dinge.</p>
                    <p>‚úÖ Schnelles Lernen<br>
                    ‚ö†Ô∏è Risiko f√ºr Reward Hacking</p>
                `,
                tags: ['training', 'dense'],
            },
            {
                id: 'gordon_80m',
                filename: 'replays/Gordon_80M.json',
                title: 'Gordon - 80M Steps',
                shortDesc: 'Dense Rewards - Fortgeschritten',
                description: `
                    <p>Bei <strong>80M Steps</strong> ist Gordon sehr aktiv, aber oft ineffizient. Er optimiert die Rewards, nicht unbedingt den Sieg.</p>
                    <p>‚úÖ Hyperaktiv<br>
                    ‚ö†Ô∏è Manchmal ziellos<br>
                    ‚ö†Ô∏è Fokus auf Punkte statt Strategie</p>
                `,
                tags: ['training', 'dense'],
            },
            {
                id: 'gordon_100m',
                filename: 'replays/Gordon_100M.json',
                title: 'Gordon - 100M Steps',
                shortDesc: 'Dense Rewards - Final',
                description: `
                    <p>Finales Modell. Gordon ist effizient, aber vorhersehbar. Er hat gelernt, die Rewards zu maximieren.</p>
                    <p>‚úÖ Schnelle Entwicklung<br>
                    ‚ö†Ô∏è Vorhersehbares Verhalten<br>
                    ‚ö†Ô∏è Anf√§llig f√ºr Exploitation</p>
                `,
                tags: ['training', 'dense'],
            },

            // =========================================
            // ALGERNON (Balanced Rewards)
            // =========================================
            {
                id: 'algernon_40m',
                filename: 'replays/Algernon_40M.json',
                title: 'Algernon - 40M Steps',
                shortDesc: 'Balanced Rewards - Fr√ºhe Phase',
                description: `
                    <p><span class="highlight">Algernon</span> nutzt <strong>Balanced Rewards</strong> - der goldene Mittelweg.</p>
                    <p>Bei <strong>40M Steps</strong> zeigt Algernon schon bessere Koordination als Charlie, aber weniger Hyperaktivit√§t als Gordon.</p>
                    <p>‚úÖ Ausgeglichenes Lernen<br>
                    ‚úÖ Fokus auf wichtige Aktionen</p>
                `,
                tags: ['training', 'balanced'],
            },
            {
                id: 'algernon_80m',
                filename: 'replays/Algernon_80M.json',
                title: 'Algernon - 80M Steps',
                shortDesc: 'Balanced Rewards - Fortgeschritten',
                description: `
                    <p>Bei <strong>80M Steps</strong> entwickelt Algernon klare taktische Muster. Er versteht Timing und Positionierung.</p>
                    <p>‚úÖ Koordiniert<br>
                    ‚úÖ Zielgerichtet<br>
                    ‚úÖ Adaptive Strategien</p>
                `,
                tags: ['training', 'balanced'],
            },
            {
                id: 'algernon_100m',
                filename: 'replays/Algernon_100M.json',
                title: 'Algernon - 100M Steps',
                shortDesc: 'Balanced Rewards - Final',
                description: `
                    <p>Finales Modell und <span class="highlight">klarer Gewinner</span> des Experiments. Algernon kombiniert Effizienz mit Kreativit√§t.</p>
                    <p>‚úÖ Beste Performance<br>
                    ‚úÖ Koordinierte Teamarbeit<br>
                    ‚úÖ Kreative Taktiken<br>
                    ‚úÖ Hohe Win Rate</p>
                `,
                tags: ['training', 'balanced', 'best'],
            },
        ];
    </script>
    
    <script>
        // ==========================================
        // THREE.JS VISUALISIERUNG
        // ==========================================
        let scene, camera, renderer;
        let replayData = null;
        let currentFrame = 0;
        let isPlaying = true;
        let playbackSpeed = 1;
        let lastFrameTime = 0;
        const FRAME_DURATION = 50;
        let tackle_cooldown = 65;
        let stun_duration = 20;
        let animationTime = 0;

        const agentMeshes = {};
        const flagMeshes = {};
        const wallMeshes = [];

        function init() {
            setupScene();
            setupLights();
            setupGround();
            setupBases();
            setupWalls();
            setupControls();
            buildReplayList();
            
            // Lade erstes Replay
            if (window.EMBEDDED_REPLAYS && window.EMBEDDED_REPLAYS.length > 0) {
                loadReplayByIndex(window.EMBEDDED_REPLAYS.length - 1); // Algernon 100M
            }
            
            animate(0);
        }

        function setupScene() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f1a);
            scene.fog = new THREE.Fog(0x0f0f1a, 40, 80);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 25, 35);
            camera.lookAt(12, 0, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Kamera-Steuerung
            let isDragging = false;
            let prevMouse = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', e => {
                isDragging = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            renderer.domElement.addEventListener('mouseup', () => isDragging = false);
            renderer.domElement.addEventListener('mouseleave', () => isDragging = false);
            renderer.domElement.addEventListener('mousemove', e => {
                if (!isDragging) return;
                camera.position.x -= (e.clientX - prevMouse.x) * 0.05;
                camera.position.z -= (e.clientY - prevMouse.y) * 0.05;
                camera.lookAt(12, 0, 12);
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            renderer.domElement.addEventListener('wheel', e => {
                camera.position.y = Math.max(10, Math.min(50, camera.position.y + e.deltaY * 0.02));
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setupLights() {
            // Ambient Light f√ºr Grundbeleuchtung
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            
            // Hauptlicht (Sonne)
            const sun = new THREE.DirectionalLight(0xffffff, 0.9);
            sun.position.set(20, 35, 20);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 100;
            sun.shadow.camera.left = -30;
            sun.shadow.camera.right = 30;
            sun.shadow.camera.top = 30;
            sun.shadow.camera.bottom = -30;
            scene.add(sun);
            
            // Hemisphere Light f√ºr nat√ºrlichere Beleuchtung
            scene.add(new THREE.HemisphereLight(0x6c63ff, 0x0f0f1a, 0.4));
            
            // Punktlicht auf jeder Basis f√ºr Atmosph√§re
            const blueLight = new THREE.PointLight(0x4dabf7, 0.5, 10);
            blueLight.position.set(2, 3, 12);
            scene.add(blueLight);
            
            const redLight = new THREE.PointLight(0xff6b6b, 0.5, 10);
            redLight.position.set(22, 3, 12);
            scene.add(redLight);
        }

        function setupGround() {
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 30),
                new THREE.MeshStandardMaterial({ color: 0x1a1a2e })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(12, -0.01, 12);
            ground.receiveShadow = true;
            scene.add(ground);

            const grid = new THREE.GridHelper(24, 24, 0x333366, 0x222244);
            grid.position.set(12, 0, 12);
            scene.add(grid);
        }

        function setupBases() {
            // Blue Base
            const blueMat = new THREE.MeshStandardMaterial({ 
                color: 0x4dabf7, 
                transparent: true, 
                opacity: 0.4,
                emissive: 0x4dabf7,
                emissiveIntensity: 0.1
            });
            const blueBase = new THREE.Mesh(new THREE.PlaneGeometry(4, 8), blueMat);
            blueBase.rotation.x = -Math.PI / 2;
            blueBase.position.set(2, 0.02, 12);
            scene.add(blueBase);
            
            // Blue Base Border
            const blueBorder = new THREE.Mesh(
                new THREE.RingGeometry(2.8, 3, 4),
                new THREE.MeshBasicMaterial({ color: 0x4dabf7, transparent: true, opacity: 0.6 })
            );
            blueBorder.rotation.x = -Math.PI / 2;
            blueBorder.rotation.z = Math.PI / 4;
            blueBorder.position.set(2, 0.03, 12);
            scene.add(blueBorder);

            // Red Base
            const redMat = new THREE.MeshStandardMaterial({ 
                color: 0xff6b6b, 
                transparent: true, 
                opacity: 0.4,
                emissive: 0xff6b6b,
                emissiveIntensity: 0.1
            });
            const redBase = new THREE.Mesh(new THREE.PlaneGeometry(4, 8), redMat);
            redBase.rotation.x = -Math.PI / 2;
            redBase.position.set(22, 0.02, 12);
            scene.add(redBase);
            
            // Red Base Border
            const redBorder = new THREE.Mesh(
                new THREE.RingGeometry(2.8, 3, 4),
                new THREE.MeshBasicMaterial({ color: 0xff6b6b, transparent: true, opacity: 0.6 })
            );
            redBorder.rotation.x = -Math.PI / 2;
            redBorder.rotation.z = Math.PI / 4;
            redBorder.position.set(22, 0.03, 12);
            scene.add(redBorder);
        }

        function setupWalls(customWalls = null) {
            wallMeshes.forEach(m => scene.remove(m));
            wallMeshes.length = 0;

            const walls = customWalls || [
                { x_min: 10, x_max: 11, y_min: 10, y_max: 11 },
                { x_min: 13, x_max: 14, y_min: 10, y_max: 11 },
                { x_min: 10, x_max: 11, y_min: 13, y_max: 14 },
                { x_min: 13, x_max: 14, y_min: 13, y_max: 14 },
                { x_min: 5, x_max: 7, y_min: 4, y_max: 5 },
                { x_min: 5, x_max: 7, y_min: 19, y_max: 20 },
                { x_min: 17, x_max: 19, y_min: 4, y_max: 5 },
                { x_min: 17, x_max: 19, y_min: 19, y_max: 20 }
            ];

            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a3a4a,
                roughness: 0.8,
                metalness: 0.2
            });

            walls.forEach(wall => {
                const width = wall.x_max - wall.x_min;
                const depth = wall.y_max - wall.y_min;
                
                const mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(width, 1.5, depth),
                    wallMaterial
                );
                mesh.position.set(
                    (wall.x_min + wall.x_max) / 2, 
                    0.75, 
                    (wall.y_min + wall.y_max) / 2
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                wallMeshes.push(mesh);
                
                // Wand-Top als Akzent
                const topMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(width + 0.1, 0.1, depth + 0.1),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x5a5a6a,
                        roughness: 0.5,
                        metalness: 0.3
                    })
                );
                topMesh.position.set(
                    (wall.x_min + wall.x_max) / 2, 
                    1.55, 
                    (wall.y_min + wall.y_max) / 2
                );
                scene.add(topMesh);
                wallMeshes.push(topMesh);
            });
        }

        function setupControls() {
            document.getElementById('play-btn').onclick = () => {
                isPlaying = true;
                document.getElementById('play-btn').classList.add('active');
                document.getElementById('pause-btn').classList.remove('active');
            };
            document.getElementById('pause-btn').onclick = () => {
                isPlaying = false;
                document.getElementById('pause-btn').classList.add('active');
                document.getElementById('play-btn').classList.remove('active');
            };
            document.getElementById('reset-btn').onclick = () => {
                currentFrame = 0;
                updateScene();
            };
            document.getElementById('speed').oninput = e => {
                playbackSpeed = parseFloat(e.target.value);
                document.getElementById('speed-val').textContent = playbackSpeed + 'x';
            };
            document.querySelector('.upload-btn').onclick = () => {
                document.getElementById('file-input').click();
            };
            document.getElementById('file-input').onchange = e => {
                if (e.target.files[0]) loadReplayFromFile(e.target.files[0]);
            };
        }

        // ==========================================
        // REPLAY LISTE BAUEN
        // ==========================================
        function buildReplayList() {
            // Replays nach Modell gruppieren
            const modelGroups = {
                charlie: [],
                gordon: [],
                algernon: []
            };

            window.EMBEDDED_REPLAYS.forEach((replay, index) => {
                const model = replay.id.split('_')[0]; // charlie, gordon, algernon
                if (modelGroups[model]) {
                    modelGroups[model].push({ replay, index });
                }
            });

            // F√ºr jedes Modell die Replays einf√ºgen
            Object.entries(modelGroups).forEach(([model, replays]) => {
                const container = document.querySelector(`.model-replays[data-model="${model}"]`);
                if (!container) return;

                container.innerHTML = '';

                replays.forEach(({ replay, index }) => {
                    const steps = replay.id.split('_')[1].toUpperCase(); // 40m, 80m, 100m
                    let phase = 'Fr√ºh';
                    if (steps === '80M') phase = 'Mitte';
                    if (steps === '100M') phase = 'Final';

                    const item = document.createElement('div');
                    item.className = `replay-list-item ${model}`;
                    item.dataset.index = index;

                    item.innerHTML = `
                        <span class="replay-name">${steps} Steps</span>
                        <span class="step-badge">${phase}</span>
                    `;

                    item.onclick = () => loadReplayByIndex(index);
                    container.appendChild(item);
                });
            });
        }

        function loadReplayByIndex(index) {
            const replay = window.EMBEDDED_REPLAYS[index];
            if (!replay) return;

            // Active-State setzen
            document.querySelectorAll('.replay-list-item').forEach(el => {
                el.classList.remove('active');
            });
            const activeItem = document.querySelector(`.replay-list-item[data-index="${index}"]`);
            if (activeItem) activeItem.classList.add('active');

            // Kontext-Panel updaten
            document.getElementById('replay-title').textContent = replay.title;
            document.getElementById('replay-description').innerHTML = replay.description;
            document.getElementById('no-replay-hint')?.remove();

            // Tags
            const tagsContainer = document.getElementById('replay-tags');
            tagsContainer.innerHTML = replay.tags.map(tag => 
                `<span class="replay-tag tag-${tag}">${tag}</span>`
            ).join('');

            // Replay laden
            loadReplayFile(replay.filename);
        }

        async function loadReplayFile(filename) {
            document.getElementById('loading').style.display = 'block';

            try {
                const res = await fetch(filename);
                const data = await res.json();

                if (!data.frames || data.frames.length === 0) throw new Error('Keine Frames');

                replayData = data;
                if (data.metadata?.tackle_cooldown) tackle_cooldown = data.metadata.tackle_cooldown;
                if (data.metadata?.stun_duration) stun_duration = data.metadata.stun_duration;
                if (data.metadata?.walls) setupWalls(data.metadata.walls);

                clearAgents();
                createAgents();
                createFlags();

                currentFrame = 0;
                updateScene();

                // Meta-Infos
                document.getElementById('replay-meta').style.display = 'block';
                document.getElementById('meta-frames').textContent = data.frames.length;
                document.getElementById('meta-agents').textContent = Object.keys(data.frames[0].agents).length;
                document.getElementById('meta-map').textContent = '24x24';

                document.getElementById('loading').style.display = 'none';
            } catch (err) {
                console.error('Load error:', err);
                document.getElementById('loading').innerHTML = `<p style="color:#ff6b6b;">‚ö†Ô∏è Replay nicht gefunden: ${filename}</p>`;
            }
        }

        function loadReplayFromFile(file) {
            document.getElementById('loading').style.display = 'block';
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!data.frames) throw new Error('Ung√ºltiges Format');
                    
                    replayData = data;
                    clearAgents();
                    createAgents();
                    createFlags();
                    currentFrame = 0;
                    updateScene();
                    
                    document.getElementById('replay-title').textContent = file.name;
                    document.getElementById('replay-description').innerHTML = '<p>Eigenes Replay aus lokaler Datei geladen.</p>';
                    document.getElementById('replay-tags').innerHTML = '<span class="replay-tag tag-custom">Custom</span>';
                    
                    document.getElementById('loading').style.display = 'none';
                } catch (err) {
                    document.getElementById('loading').innerHTML = `<p style="color:#ff6b6b;">‚ö†Ô∏è Fehler: ${err.message}</p>`;
                }
            };
            reader.readAsText(file);
        }

        // ==========================================
        // AGENT & FLAG CREATION (VERBESSERT)
        // ==========================================
        function clearAgents() {
            Object.values(agentMeshes).forEach(m => scene.remove(m));
            Object.values(flagMeshes).forEach(m => scene.remove(m));
            Object.keys(agentMeshes).forEach(k => delete agentMeshes[k]);
            Object.keys(flagMeshes).forEach(k => delete flagMeshes[k]);
        }

        function createAgents() {
            if (!replayData?.frames?.[0]?.agents) return;

            Object.entries(replayData.frames[0].agents).forEach(([id, data]) => {
                const isBlue = data.team === 'blue';
                const color = isBlue ? 0x4dabf7 : 0xff6b6b;

                const agent = new THREE.Group();
                agent.userData = { 
                    team: data.team, 
                    originalColor: color,
                    lastPosition: { x: data.position[0], z: data.position[1] },
                    velocity: { x: 0, z: 0 },
                    targetRotation: 0,
                    isMoving: false,
                    bobPhase: Math.random() * Math.PI * 2 // Zuf√§lliger Start f√ºr Lauf-Animation
                };

                // K√∂rper-Container f√ºr Animationen
                const bodyContainer = new THREE.Group();
                bodyContainer.name = 'bodyContainer';
                agent.add(bodyContainer);

                // Hauptk√∂rper
                const body = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.4, 0.8, 8, 16),
                    new THREE.MeshStandardMaterial({ 
                        color,
                        roughness: 0.4,
                        metalness: 0.1
                    })
                );
                body.castShadow = true;
                body.name = 'body';
                bodyContainer.add(body);

                // Gesicht-Container (f√ºr Augen-Rotation bei Stun)
                const faceContainer = new THREE.Group();
                faceContainer.name = 'faceContainer';
                faceContainer.position.set(0, 0.3, 0.35);
                body.add(faceContainer);

                // Augen mit besserer Struktur
                [-0.15, 0.15].forEach((x, idx) => {
                    // Augapfel
                    const eyeWhite = new THREE.Mesh(
                        new THREE.SphereGeometry(0.12, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0xffffff })
                    );
                    eyeWhite.position.set(x, 0, 0);
                    eyeWhite.name = idx === 0 ? 'eyeLeft' : 'eyeRight';
                    faceContainer.add(eyeWhite);
                    
                    // Pupille (bewegt sich)
                    const pupil = new THREE.Mesh(
                        new THREE.SphereGeometry(0.06, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0x111111 })
                    );
                    pupil.position.set(0, 0, 0.08);
                    pupil.name = 'pupil';
                    eyeWhite.add(pupil);
                });

                // Stun-Spiralen (versteckt bis ben√∂tigt)
                const stunGroup = new THREE.Group();
                stunGroup.name = 'stunGroup';
                stunGroup.visible = false;
                stunGroup.position.set(0, 0.5, 0);
                body.add(stunGroup);

                // Spiralen-Augen f√ºr Stun
                [-0.2, 0.2].forEach((x, idx) => {
                    const spiralGroup = new THREE.Group();
                    spiralGroup.position.set(x, 0, 0.4);
                    spiralGroup.name = idx === 0 ? 'spiralLeft' : 'spiralRight';
                    
                    // Spiral-Linien
                    const spiralMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    for (let i = 0; i < 2; i++) {
                        const line = new THREE.Mesh(
                            new THREE.BoxGeometry(0.18, 0.03, 0.01),
                            spiralMat
                        );
                        line.rotation.z = (i * Math.PI / 2);
                        spiralGroup.add(line);
                    }
                    stunGroup.add(spiralGroup);
                });

                // Sterne √ºber dem Kopf bei Stun
                const starsGroup = new THREE.Group();
                starsGroup.name = 'starsGroup';
                starsGroup.visible = false;
                starsGroup.position.set(0, 0.9, 0);
                body.add(starsGroup);

                for (let i = 0; i < 3; i++) {
                    const star = createStar(0.12, 0xffd43b);
                    star.position.set(
                        Math.cos(i * Math.PI * 2 / 3) * 0.3,
                        0,
                        Math.sin(i * Math.PI * 2 / 3) * 0.3
                    );
                    star.name = `star${i}`;
                    starsGroup.add(star);
                }

                // Aura f√ºr Flaggentr√§ger (verbessert)
                const aura = new THREE.Mesh(
                    new THREE.RingGeometry(0.5, 0.7, 32),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffd43b, 
                        transparent: true, 
                        opacity: 0, 
                        side: THREE.DoubleSide 
                    })
                );
                aura.rotation.x = -Math.PI / 2;
                aura.position.y = -0.7;
                aura.name = 'aura';
                agent.add(aura);

                // Schatten unter dem Agenten
                const shadow = new THREE.Mesh(
                    new THREE.CircleGeometry(0.5, 32),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x000000, 
                        transparent: true, 
                        opacity: 0.3 
                    })
                );
                shadow.rotation.x = -Math.PI / 2;
                shadow.position.y = -0.79;
                shadow.name = 'shadow';
                agent.add(shadow);

                agent.position.set(data.position[0], 0.8, data.position[1]);
                scene.add(agent);
                agentMeshes[id] = agent;
            });
        }

        // Stern-Geometrie f√ºr Stun-Effekt
        function createStar(size, color) {
            const shape = new THREE.Shape();
            const points = 5;
            const outerRadius = size;
            const innerRadius = size * 0.4;
            
            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / points - Math.PI / 2;
                if (i === 0) {
                    shape.moveTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                } else {
                    shape.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                }
            }
            shape.closePath();
            
            const geometry = new THREE.ShapeGeometry(shape);
            const material = new THREE.MeshBasicMaterial({ 
                color, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            return new THREE.Mesh(geometry, material);
        }

        function createFlags() {
            ['blue', 'red'].forEach(team => {
                const color = team === 'blue' ? 0x4dabf7 : 0xff6b6b;
                const flagGroup = new THREE.Group();

                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 2),
                    new THREE.MeshStandardMaterial({ color: 0x888888 })
                );
                flagGroup.add(pole);

                const flag = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.8, 0.5),
                    new THREE.MeshStandardMaterial({ color, side: THREE.DoubleSide, emissive: color, emissiveIntensity: 0.3 })
                );
                flag.position.set(0.4, 0.5, 0);
                pole.add(flag);

                flagGroup.position.set(team === 'blue' ? 2 : 22, 1, 12);
                scene.add(flagGroup);
                flagMeshes[team] = flagGroup;
            });
        }

        // ==========================================
        // UPDATE & ANIMATION (VERBESSERT)
        // ==========================================
        function updateScene() {
            if (!replayData?.frames?.[currentFrame]) return;

            const frame = replayData.frames[currentFrame];
            const deltaTime = 0.016;
            animationTime += deltaTime;

            // Flaggentr√§ger finden
            const flagCarriers = {};
            Object.entries(frame.flags).forEach(([team, data]) => {
                if (data.carried_by) flagCarriers[data.carried_by] = team;
            });

            // Agenten updaten
            Object.entries(frame.agents).forEach(([id, data]) => {
                const agent = agentMeshes[id];
                if (!agent) return;

                const ud = agent.userData;
                const bodyContainer = agent.getObjectByName('bodyContainer');
                const body = agent.getObjectByName('body');
                const faceContainer = agent.getObjectByName('faceContainer');
                const stunGroup = agent.getObjectByName('stunGroup');
                const starsGroup = agent.getObjectByName('starsGroup');
                const aura = agent.getObjectByName('aura');
                const shadow = agent.getObjectByName('shadow');

                // Berechne Geschwindigkeit und Bewegung
                const targetX = data.position[0];
                const targetZ = data.position[1];
                const dx = targetX - ud.lastPosition.x;
                const dz = targetZ - ud.lastPosition.z;
                const speed = Math.sqrt(dx * dx + dz * dz);
                
                ud.velocity.x = dx;
                ud.velocity.z = dz;
                ud.isMoving = speed > 0.01;

                // Position interpolieren (smooth)
                agent.position.x += (targetX - agent.position.x) * 0.2;
                agent.position.z += (targetZ - agent.position.z) * 0.2;

                // =====================
                // DREHUNG IN BEWEGUNGSRICHTUNG
                // =====================
                if (ud.isMoving && !data.is_stunned) {
                    // Berechne Ziel-Rotation basierend auf Bewegungsrichtung
                    ud.targetRotation = Math.atan2(dx, dz);
                }
                
                // Smooth Rotation Interpolation
                let currentRot = bodyContainer.rotation.y;
                let targetRot = ud.targetRotation;
                
                // Handle rotation wrap-around
                let diff = targetRot - currentRot;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                
                bodyContainer.rotation.y += diff * 0.15;

                // =====================
                // LAUF-ANIMATION
                // =====================
                if (ud.isMoving && !data.is_stunned) {
                    ud.bobPhase += deltaTime * 15 * Math.min(speed * 5, 1);
                    
                    // Bounce (auf und ab)
                    const bounce = Math.abs(Math.sin(ud.bobPhase)) * 0.12;
                    bodyContainer.position.y = bounce;
                    
                    // Leichtes Wackeln (links/rechts tilt)
                    bodyContainer.rotation.z = Math.sin(ud.bobPhase) * 0.08;
                    
                    // Squash & Stretch
                    const squash = 1 + Math.sin(ud.bobPhase * 2) * 0.05;
                    bodyContainer.scale.set(1 / squash, squash, 1 / squash);
                    
                    // Schatten pulsiert mit Sprung
                    if (shadow) {
                        shadow.scale.set(1 - bounce * 0.5, 1 - bounce * 0.5, 1);
                        shadow.material.opacity = 0.3 - bounce * 0.3;
                    }
                } else if (!data.is_stunned) {
                    // Zur√ºck zur Ruheposition
                    bodyContainer.position.y *= 0.9;
                    bodyContainer.rotation.z *= 0.9;
                    bodyContainer.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                    
                    if (shadow) {
                        shadow.scale.set(1, 1, 1);
                        shadow.material.opacity = 0.3;
                    }
                }

                // =====================
                // STUN-ANIMATION
                // =====================
                if (data.is_stunned) {
                    // Graue Farbe
                    body.material.color.setHex(0x555555);
                    body.material.emissive = new THREE.Color(0x000000);
                    
                    // Wackeliger K√∂rper
                    bodyContainer.rotation.z = Math.sin(animationTime * 8) * 0.2;
                    bodyContainer.position.y = Math.sin(animationTime * 4) * 0.05;
                    
                    // Normale Augen verstecken, Stun-Spiralen zeigen
                    if (faceContainer) faceContainer.visible = false;
                    if (stunGroup) {
                        stunGroup.visible = true;
                        // Spiralen drehen
                        stunGroup.children.forEach((spiral, idx) => {
                            spiral.rotation.z = animationTime * 10 * (idx === 0 ? 1 : -1);
                        });
                    }
                    
                    // Sterne √ºber dem Kopf
                    if (starsGroup) {
                        starsGroup.visible = true;
                        starsGroup.rotation.y = animationTime * 3;
                        starsGroup.children.forEach((star, idx) => {
                            star.position.y = Math.sin(animationTime * 5 + idx * 2) * 0.15;
                            star.rotation.z = animationTime * 2;
                        });
                    }
                    
                    // Schatten kleiner
                    if (shadow) {
                        shadow.scale.set(0.7, 0.7, 1);
                        shadow.material.opacity = 0.2;
                    }
                } else {
                    // Normale Farbe
                    body.material.color.setHex(ud.originalColor);
                    
                    // Normale Augen zeigen, Stun-Effekte verstecken
                    if (faceContainer) faceContainer.visible = true;
                    if (stunGroup) stunGroup.visible = false;
                    if (starsGroup) starsGroup.visible = false;
                    
                    // Pupillen schauen in Bewegungsrichtung
                    if (faceContainer && ud.isMoving) {
                        const eyeLeft = faceContainer.getObjectByName('eyeLeft');
                        const eyeRight = faceContainer.getObjectByName('eyeRight');
                        [eyeLeft, eyeRight].forEach(eye => {
                            if (eye) {
                                const pupil = eye.getObjectByName('pupil');
                                if (pupil) {
                                    // Pupillen leicht in Bewegungsrichtung verschieben
                                    pupil.position.x = Math.sin(bodyContainer.rotation.y) * 0.02;
                                    pupil.position.y = 0;
                                }
                            }
                        });
                    }
                }

                // =====================
                // FLAGGENTR√ÑGER-EFFEKTE
                // =====================
                if (flagCarriers[id]) {
                    if (aura) {
                        aura.material.opacity = 0.6 + Math.sin(animationTime * 5) * 0.2;
                        aura.rotation.z = animationTime * 2;
                    }
                    if (!data.is_stunned) {
                        body.material.emissive = new THREE.Color(0xffd43b);
                        body.material.emissiveIntensity = 0.15 + Math.sin(animationTime * 4) * 0.1;
                    }
                } else {
                    if (aura) aura.material.opacity = 0;
                    if (!data.is_stunned) {
                        body.material.emissive = new THREE.Color(0x000000);
                        body.material.emissiveIntensity = 0;
                    }
                }

                // Position f√ºr n√§chsten Frame speichern
                ud.lastPosition.x = targetX;
                ud.lastPosition.z = targetZ;
            });

            // =====================
            // FLAGGEN UPDATEN
            // =====================
            Object.entries(frame.flags).forEach(([team, data]) => {
                const flagGroup = flagMeshes[team];
                if (!flagGroup) return;

                const carrier = data.carried_by ? agentMeshes[data.carried_by] : null;
                if (carrier) {
                    flagGroup.position.x = carrier.position.x;
                    flagGroup.position.z = carrier.position.z;
                    flagGroup.position.y = 2.2 + Math.sin(animationTime * 4) * 0.1;
                    
                    // Flagge weht st√§rker wenn getragen
                    const flag = flagGroup.children[0]?.children[0];
                    if (flag) {
                        flag.rotation.y = Math.sin(animationTime * 8) * 0.3;
                    }
                } else {
                    flagGroup.position.x += (data.position[0] - flagGroup.position.x) * 0.2;
                    flagGroup.position.z += (data.position[1] - flagGroup.position.z) * 0.2;
                    flagGroup.position.y = 1;
                    
                    // Flagge weht sanft
                    const flag = flagGroup.children[0]?.children[0];
                    if (flag) {
                        flag.rotation.y = Math.sin(animationTime * 3) * 0.1;
                    }
                }
            });

            // =====================
            // UI UPDATEN
            // =====================
            document.getElementById('step-display').textContent = 'Step: ' + frame.step;
            document.getElementById('blue-score').textContent = frame.scores.blue;
            document.getElementById('red-score').textContent = frame.scores.red;

            // Flaggen-Status
            ['blue', 'red'].forEach(team => {
                const el = document.getElementById(`${team}-flag-status`);
                const flagData = frame.flags[team];
                if (flagData.carried_by) {
                    el.classList.add('carried');
                    el.classList.remove('at-base');
                    el.querySelector('.carrier-name').textContent = `${flagData.carried_by}`;
                } else {
                    el.classList.remove('carried');
                    el.classList.add('at-base');
                    el.querySelector('.carrier-name').textContent = 'An der Basis';
                }
            });
        }

        function animate(timestamp) {
            requestAnimationFrame(animate);

            if (isPlaying && replayData) {
                const elapsed = timestamp - lastFrameTime;
                if (elapsed > FRAME_DURATION / playbackSpeed) {
                    currentFrame = (currentFrame + 1) % replayData.frames.length;
                    lastFrameTime = timestamp;
                }
            }

            updateScene();
            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>
